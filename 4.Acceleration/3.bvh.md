# 1.1 Bounding volume hierarchies
包围体层次结构根据图元细分实现了一种光线相交加速方案. 如下图所示:

图元集合的包围盒由虚线表示, 图元的分组方式根据邻近程度予以实现. 圆和正三角形由一个包围盒包围, 整个场景又由一个大包围盒包围起来(这两个包围盒用实线表示). 最终就会构造出(b)所示的二叉树.

![BVH](figures/4.1.png)

表示 BVH 所需要的内存通常是有限并且可计算的. 对于各个叶子节点存储单一图元的 BVH 二叉树而言, 全部节点数量最多为 $2n-1$, 其中 $n$ 表示图元数量, 叶子节点和内部节点数量分别为 $n$ 和 $n-1$.

与 BVH 相比, 后面要介绍的 kd 树通常可以实现快速的相交计算, 但是其构造过程要更长一些. 另外与 kd 树相比, BVH 具有更好的数值健壮性以及针对舍入误差问题的抗干扰性.

# 1.2 构建 BVH
构建 BVH 分为三个阶段. 首先计算所有图元的包围信息存储在数组中. 然后将根据 *splitMethod* 指定的算法来构建 BVH 二叉树. 最后将这个树形结构转换为更紧凑的无指针表达方式, 以供渲染操作使用.

我们定义一个结构体 *BVHPrimitiveInfo* 来存储 BVH. 每个 BVHPrimitiveInfo 实例都保存着图元的形心, 包围盒以及其在 BVHPrimitiveInfo 数组中的下标.

```c++
// BVHPrimitiveInfo 结构体
struct BVHPrimitiveInfo {
	BVHPrimitiveInfo(size_t primitiveNumber, const Bounds3f &bounds)
	: primitiveNumber(primitiveNumber), bounds(bounds),
	centroid(.5f * bounds.pMin + .5f * bounds.pMax) { }

	size_t primitiveNumber;
	Bounds3f bounds;
	Point3f centroid;
};

// 初始化 primitiveInfo 数组
std::vector<BVHPrimitiveInfo> primitiveInfo(primitives.size());
for (size_t i = 0; i < primitives.size(); ++i)
	primitiveInfo[i] = { i, primitives[i]->WorldBound() };
```

接下里就可以开始递归构造过程了.